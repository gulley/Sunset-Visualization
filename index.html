<!DOCTYPE HTML> 
<html>
  <head>
    <title>Sunset Times</title>
    <!-- Material Design Lite CSS and JS -->
    <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.blue_grey-red.min.css" />
    <script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>

    <!-- Fonts -->
    <link href='https://fonts.googleapis.com/css?family=Roboto:400,500,700' rel='stylesheet' type='text/css'>

    <!-- SunCalc library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/suncalc/1.8.0/suncalc.min.js"></script>

    <style>
      html, body {
        font-family: 'Roboto', sans-serif;
        background-color: #FAFAFA;
        margin: 0;
        padding: 0;
      }

      .mdl-layout__content {
        padding: 20px;
      }

      .clock-card {
        width: 100%;
        max-width: 600px;
        margin: auto;
      }

      .clock-card .mdl-card__supporting-text {
        text-align: center;
      }

      .time-table th, .time-table td {
        text-align: left;
      }

      .time-table th.mdl-data-table__cell--non-numeric {
        text-align: left;
      }

      .clock-canvas {
        display: block;
        margin: 20px auto;
      }
    </style>

    <script type="text/javascript">
      // Sunset Clock Application
      const SC = {};

      const defaultLatitude = 42.3653766;
      const defaultLongitude = -71.1853512;

      SC.Sunset = {
        draw: {

          /**
           * Draws a clock hand on the canvas.
           * @param {CanvasRenderingContext2D} ctx - The canvas context.
           * @param {number} angle - The angle of the hand in radians.
           * @param {string} color - The color of the hand.
           * @param {number} length - The length of the hand.
           * @param {number} width - The width of the hand.
           */
          drawHand: (ctx, angle, color, length, width) => {
            const center = 200;
            ctx.beginPath();
            ctx.moveTo(center, center);
            ctx.lineTo(
              center + length * Math.cos(angle),
              center + length * Math.sin(angle)
            );
            ctx.lineWidth = width;
            ctx.strokeStyle = color;
            ctx.stroke();
          },

          /**
           * Draws the minute hand representing the sunset time.
           * @param {CanvasRenderingContext2D} ctx - The canvas context.
           * @param {number} timeInHours - The time in decimal hours.
           * @param {string} color - The color of the minute hand.
           * @param {number} width - The width of the minute hand.
           */
          drawMinuteHand: (ctx, timeInHours, color, width) => {
            if (timeInHours === null) return; // If invalid time
            const hours = Math.floor(timeInHours);
            const minutes = Math.floor((timeInHours - hours) * 60);
            let angle = 2 * Math.PI * (timeInHours - hours);
            // Adjust angle so that 12:00 is at the top
            angle -= Math.PI / 2;
            const length = 180;
            SC.Sunset.draw.drawHand(ctx, angle, color, length, width);
          },

          /**
           * Draws the hour hand representing the sunset time.
           * @param {CanvasRenderingContext2D} ctx - The canvas context.
           * @param {number} timeInHours - The time in decimal hours.
           */
          drawHourHand: (ctx, timeInHours) => {
            if (timeInHours === null) return; // If invalid time
            let hours = Math.floor(timeInHours);
            const minutes = Math.floor((timeInHours - hours) * 60);
            let angle = 2 * Math.PI * ((hours + minutes / 60.0) / 12.0);
            // Adjust angle so that 12:00 is at the top
            angle -= Math.PI / 2;
            SC.Sunset.draw.drawHand(ctx, angle, "#000000", 100, 10);
          },

          /**
           * Draws the clock face or the center circle (nose).
           * @param {CanvasRenderingContext2D} ctx - The canvas context.
           * @param {string} option - 'face' to draw the clock face, 'nose' to draw the center circle.
           */
          drawClockFace: (ctx, option) => {
            const center = ctx.canvas.getAttribute("width") / 2;

            if (option === "face") {
              // Draw the outer circle of the clock face
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(center, center, 195, 0, Math.PI * 2, true);
              ctx.closePath();
              ctx.fillStyle = "#FFFFFF";
              ctx.fill();
              ctx.stroke();

              // Draw the hour numbers on the clock
              ctx.font = "24px Roboto";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillStyle = "#000";

              const numberRadius = 160; // Radius for numbers
              for (let i = 1; i <= 12; i++) {
                const angle = (i * 30) * Math.PI / 180; // Each hour is 30 degrees
                const x = center + numberRadius * Math.cos(angle - Math.PI / 2);
                const y = center + numberRadius * Math.sin(angle - Math.PI / 2);
                ctx.fillText(i.toString(), x, y);
              }

              // Draw minute marks for each 5-minute increment
              for (let mark = 0; mark < 60; mark++) {
                const angle = (mark * 6) * Math.PI / 180; // Each minute is 6 degrees
                const length = (mark % 5 === 0) ? 10 : 5; // Longer marks for hours
                const innerRadius = 195 - length;
                const outerRadius = 195;
                const x1 = center + innerRadius * Math.cos(angle - Math.PI / 2);
                const y1 = center + innerRadius * Math.sin(angle - Math.PI / 2);
                const x2 = center + outerRadius * Math.cos(angle - Math.PI / 2);
                const y2 = center + outerRadius * Math.sin(angle - Math.PI / 2);
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.lineWidth = (mark % 5 === 0) ? 4 : 1.5;
                ctx.stroke();
              }
            }

            if (option === "nose") {
              // Draw the center circle (nose)
              ctx.beginPath();
              ctx.arc(center, center, 10, 0, Math.PI * 2, true);
              ctx.closePath();
              ctx.fillStyle = "#000000";
              ctx.fill();
            }
          }
        },

        format: {

          /**
           * Converts a decimal value to a hexadecimal string with specified digits.
           * @param {number} value - The decimal value to convert.
           * @param {number} numDigits - The desired length of the hexadecimal string.
           * @returns {string} - The hexadecimal string.
           */
          toHex: (value, numDigits) => {
            let str = value.toString(16);
            while (str.length < numDigits) {
              str = "0" + str;
            }
            return str;
          },

          /**
           * Converts time in decimal hours to a formatted time string (HH:MM:SS AM/PM).
           * @param {number} timeInHours - The time in decimal hours.
           * @returns {string} - The formatted time string.
           */
          timeToHMS: (timeInHours) => {
            if (timeInHours === null) return "N/A";
            let hours = Math.floor(timeInHours);
            const minutes = Math.floor((timeInHours - hours) * 60);
            const seconds = Math.floor((timeInHours - hours - minutes / 60) * 3600);
            let period = " AM";
            if (hours >= 12) {
              period = " PM";
              if (hours > 12) hours -= 12;
            } else if (hours === 0) {
              hours = 12;
            }
            return `${hours}:${SC.Sunset.pad(minutes)}:${SC.Sunset.pad(seconds)}${period}`;
          },

          /**
           * Converts time difference in hours to a readable string (e.g., 'X minutes Y seconds').
           * @param {number} timeInHours - The time difference in decimal hours.
           * @returns {string} - The formatted time difference string.
           */
          timeDifferenceToString: (timeInHours) => {
            const totalSeconds = Math.round(timeInHours * 3600);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const minuteStr = `${minutes} minute${minutes === 1 ? "" : "s"}`;
            const secondStr = `${seconds} second${seconds === 1 ? "" : "s"}`;
            if (minutes <= 0) {
              return secondStr;
            } else if (seconds <= 0) {
              return minuteStr;
            } else {
              return `${minuteStr} ${secondStr}`;
            }
          }

        },

        /**
         * Finds the date with the earliest sunset time within the next year.
         * @param {number} latitude - The latitude of the location.
         * @param {number} longitude - The longitude of the location.
         * @returns {Date} - The date with the earliest sunset.
         */
        getEarliestSunsetDate: (latitude, longitude) => {
          const currentDate = new Date();
          let earliestSunsetDate = new Date(currentDate);
          let earliestSunsetTime = 24.0; // Initialize with maximum possible hour
          const oneDay = 24 * 60 * 60 * 1000;

          // Cycle through the next 365 days to find the date with the earliest sunset
          for (let i = 0; i < 365; i++) {
            const dateToCheck = new Date(currentDate.getTime() + i * oneDay);
            const sunsetTime = SC.Sunset.getSunsetTime(dateToCheck, latitude, longitude);
            if (sunsetTime !== null && sunsetTime < earliestSunsetTime) {
              earliestSunsetTime = sunsetTime;
              earliestSunsetDate = new Date(dateToCheck);
            }
          }
          return earliestSunsetDate;
        },

        /**
         * Gets the sunset time for a given date and location.
         * @param {Date} date - The date for which to calculate the sunset time.
         * @param {number} latitude - The latitude of the location.
         * @param {number} longitude - The longitude of the location.
         * @returns {number|null} - The sunset time in decimal hours, or null if not available.
         */
        getSunsetTime: (date, latitude, longitude) => {
          const times = SunCalc.getTimes(date, latitude, longitude);
          const sunsetTimeUTC = times.sunset;
          if (!sunsetTimeUTC) {
            return null;
          }
          const localOffset = date.getTimezoneOffset() * 60000; // in milliseconds
          const sunsetTimeLocal = new Date(sunsetTimeUTC.getTime() - localOffset);
          const sunsetHours = sunsetTimeLocal.getUTCHours() + sunsetTimeLocal.getUTCMinutes() / 60 + sunsetTimeLocal.getUTCSeconds() / 3600;
          return sunsetHours;
        },

        /**
         * Pads a number with a leading zero if it's less than 10.
         * @param {number} number - The number to pad.
         * @returns {string} - The padded number as a string.
         */
        pad: (number) => (number < 10) ? ("0" + number) : number,

        /**
         * Initializes the application, retrieves stored location or requests geolocation.
         */
        initialize: () => {
          const storedLatitude = localStorage.getItem('sunsetLatitude');
          const storedLongitude = localStorage.getItem('sunsetLongitude');
          if (storedLatitude && storedLongitude) {
            SC.Sunset.displaySunsetTimes(parseFloat(storedLatitude), parseFloat(storedLongitude));
          } else {
            if (navigator.geolocation) {
              navigator.geolocation.getCurrentPosition(SC.Sunset.handleGeolocationSuccess, SC.Sunset.useDefaultLocation);
            } else {
              SC.Sunset.useDefaultLocation();
            }
          }
        },

        /**
         * Uses the default location if geolocation is unavailable.
         */
        useDefaultLocation: () => {
          SC.Sunset.displaySunsetTimes(defaultLatitude, defaultLongitude);
        },

        /**
         * Handles successful retrieval of geolocation data.
         * @param {GeolocationPosition} position - The position object returned by the geolocation API.
         */
        handleGeolocationSuccess: (position) => {
          const latitude = position.coords.latitude;
          const longitude = position.coords.longitude;
          localStorage.setItem('sunsetLatitude', latitude);
          localStorage.setItem('sunsetLongitude', longitude);
          SC.Sunset.displaySunsetTimes(latitude, longitude);
        },

        /**
         * Displays the sunset times and updates the clock visualization.
         * @param {number} latitude - The latitude of the location.
         * @param {number} longitude - The longitude of the location.
         */
        displaySunsetTimes: (latitude, longitude) => {
          const today = new Date();

          // Get the canvas and context
          const canvas = document.getElementById('canvas');
          const ctx = canvas.getContext("2d");
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Draw the clock face
          SC.Sunset.draw.drawClockFace(ctx, "face");

          // Draw sunset times for the next 14 days
          const futureDate = new Date();
          const maxDays = 14;
          const lineWidth = 1;
          for (let i = 0; i < maxDays; i++) {
            const colorValue = Math.floor(255 * (i / maxDays));
            const colorHex = "#" + SC.Sunset.format.toHex(colorValue, 2) + SC.Sunset.format.toHex(colorValue, 2) + "FF";
            futureDate.setDate(futureDate.getDate() + 1);
            const sunsetTime = SC.Sunset.getSunsetTime(futureDate, latitude, longitude);
            if (sunsetTime !== null) {
              SC.Sunset.draw.drawMinuteHand(ctx, sunsetTime, colorHex, lineWidth);
            }
          }

          // Get sunset times for today and tomorrow
          const sunsetToday = SC.Sunset.getSunsetTime(today, latitude, longitude);
          const tomorrow = new Date();
          tomorrow.setDate(tomorrow.getDate() + 1);
          const sunsetTomorrow = SC.Sunset.getSunsetTime(tomorrow, latitude, longitude);

          // Draw the current sunset time
          if (sunsetToday !== null) {
            SC.Sunset.draw.drawMinuteHand(ctx, sunsetToday, "#000000", 6);
            SC.Sunset.draw.drawHourHand(ctx, sunsetToday);
          }

          // Draw the center circle
          SC.Sunset.draw.drawClockFace(ctx, "nose");

          // Find the earliest sunset date
          const earliestSunsetDate = SC.Sunset.getEarliestSunsetDate(latitude, longitude);

          // Calculate the difference between today's and tomorrow's sunset times
          let timeDifference = 0;
          if (sunsetToday !== null && sunsetTomorrow !== null) {
            timeDifference = Math.abs(sunsetToday - sunsetTomorrow);
          }

          // Calculate days until the earliest sunset
          const daysUntilEarliestSunset = Math.floor((earliestSunsetDate - new Date()) / (1000 * 60 * 60 * 24)) + 1;

          // Update the HTML with sunset times
          document.querySelector(".time").innerHTML = `
            <table class='mdl-data-table mdl-js-data-table time-table'>
              <thead>
                <tr>
                  <th class='mdl-data-table__cell--non-numeric' colspan='2'>
                    Sunset for ${today.toDateString()}<br/>
                    <a class='mdl-button mdl-js-button mdl-button--raised mdl-js-ripple-effect' href='https://www.google.com/maps/?q=${latitude},${longitude}'>
                      View Location on Map
                    </a>
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td class='mdl-data-table__cell--non-numeric'>Today</td>
                  <td>${SC.Sunset.format.timeToHMS(sunsetToday)}</td>
                </tr>
                <tr>
                  <td class='mdl-data-table__cell--non-numeric'>Tomorrow</td>
                  <td>${SC.Sunset.format.timeToHMS(sunsetTomorrow)}</td>
                </tr>
                <tr>
                  <td class='mdl-data-table__cell--non-numeric'>Difference</td>
                  <td>${SC.Sunset.format.timeDifferenceToString(timeDifference)}</td>
                </tr>
                <tr>
                  <th class='mdl-data-table__cell--non-numeric' colspan='2'>Earliest Sunset</th>
                </tr>
                <tr>
                  <td class='mdl-data-table__cell--non-numeric'>Date</td>
                  <td>${earliestSunsetDate.toDateString()}</td>
                </tr>
                <tr>
                  <td class='mdl-data-table__cell--non-numeric'>Time</td>
                  <td>${SC.Sunset.format.timeToHMS(SC.Sunset.getSunsetTime(earliestSunsetDate, latitude, longitude))}</td>
                </tr>
                <tr>
                  <td class='mdl-data-table__cell--non-numeric'>Days from Now</td>
                  <td>${daysUntilEarliestSunset}</td>
                </tr>
              </tbody>
            </table>`;
        }
      };
    </script>
  </head>

  <body class="mdl-layout mdl-js-layout mdl-layout--fixed-header" onload="SC.Sunset.initialize()">
    <header class="mdl-layout__header">
      <div class="mdl-layout__header-row">
        <span class="mdl-layout-title">Sunset Times</span>
      </div>
    </header>
    <main class="mdl-layout__content">
      <div class="clock-card mdl-card mdl-shadow--2dp">
        <div class="mdl-card__title">
          <h2 class="mdl-card__title-text">Sunset Clock</h2>
        </div>
        <div class="mdl-card__supporting-text">
          <canvas id="canvas" class="clock-canvas" width="400" height="400"></canvas>
        </div>
        <div class="mdl-card__actions mdl-card--border time"></div>
      </div>
    </main>
  </body>
</html>
